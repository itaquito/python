---
sidebar_label: 'üóø Abstracci√≥n'
sidebar_position: 10
---

# üóø Abstracci√≥n

Este es el √∫ltimo pilar de la programaci√≥n orientada a objetos, y consiste en aislar un elemento de su contexto o del resto de los elementos que lo acompa√±an.

Es decir, podemos tener una clase padre con un **m√©todo abstracto** sin funcionalidad para que despu√©s sea **sobreescrito** por un m√©todo con el mismo nombre en la clase hija.

- Se define como clase abstracta la que contiene uno o m√°s m√©todos abstractos.
- M√©todo abstracto es un m√©todo que ha sido declarado pero no implementado. Para ello usamos un decorador.
- Para realizar esto, utilizamos una librer√≠a llamada `ABC` (Abstract Base Class)

```python title="Ejemplo de la abstracci√≥n de una clase"
from abc import ABC, abstractmethod

# Esta clase se ha vuelto abstracta porque hereda de ABC
class Trabajador(ABC):

  def __init__(self, nombre) -> None:
    self.nombre = nombre

  def __str__(self) -> str:
    return "Mi nombre es {self.nombre}."

  # Definimos el m√©todo trabajar() como un m√©todo abstracto por medio del decorador "@abstractmethod"
  @abstractmethod
  def trabajar(self):
    pass

# La clase constructor hereda de trabajador
class Constructor(Trabajador):

  # Sobreescribimos el m√©todo
  def trabajar(self):
    print(f"{self.nombre} est√° construyendo.")

trabajador = Constructor("El√≠as")
trabajador.trabajar() # Imprime "El√≠as est√° construyendo."
```

Es visible el hecho de que es innecesario interactuar con la clase padre, pero a√∫n as√≠ su m√©todo `trabajar()` va a aplicarse a cada uno de sus hijos. Por lo que realmente no se implementa hasta que lo tenemos en la clase `Constructor`.
